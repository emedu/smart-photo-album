# 智慧相簿自動過濾與管理系統 - 開發問答與學習筆記

**建立日期**: 2025-12-29  
**更新日期**: 2025-12-29

---

## 一、專案初始化相關

### Q1: 為什麼選擇 Node.js 而不是 Python?

**A**: 基於以下考量:
1. **統一技術棧**: 前後端都使用 JavaScript,降低學習成本
2. **非同步處理**: Node.js 的事件驅動架構適合處理大量 I/O 操作 (API 呼叫)
3. **生態系統**: npm 擁有豐富的套件,如 `googleapis` 官方支援良好
4. **部署便利**: 許多平台 (Vercel, Netlify) 對 Node.js 支援度高
5. **符合 Antigravity 協定**: 使用者的開發環境標準為 Node.js

### Q2: 為什麼不使用前端框架 (React/Vue)?

**A**: 
- **專案規模**: 此專案功能相對單純,使用原生 JavaScript 即可滿足需求
- **效能考量**: 避免額外的框架載入時間
- **學習曲線**: 降低維護門檻,任何熟悉 JavaScript 的開發者都能接手
- **未來擴充**: 若需要,可隨時遷移至框架 (建議使用 Next.js)

---

## 二、Google Photos API 相關

### Q3: 如何取得 Google Photos 分享連結中的相簿內容?

**A**: Google Photos API 不直接支援透過分享連結存取。需要以下步驟:

**方法 1: 使用 OAuth 授權**
```javascript
// 1. 使用者授權存取其 Google Photos
// 2. 透過 API 列出所有相簿
const albums = await photosClient.albums.list();

// 3. 根據相簿名稱或 ID 取得內容
const mediaItems = await photosClient.mediaItems.search({
  albumId: 'album-id-here'
});
```

**方法 2: 解析分享連結 (較複雜)**
- 分享連結格式: `https://photos.app.goo.gl/xxxxx`
- 需要透過網頁爬蟲或 Google Photos 內部 API (非官方)
- **不建議**: 違反服務條款且不穩定

**建議做法**: 
改為讓使用者直接授權存取其 Google Photos,然後從相簿清單中選擇要處理的相簿。

### Q4: Google Photos API 有哪些配額限制?

**A**: 
- **每日請求數**: 10,000 次 (免費方案)
- **每次查詢**: 最多 100 個媒體項目
- **上傳限制**: 每分鐘最多 75 MB

**應對策略**:
```javascript
// 分頁處理
async function getAllMediaItems(albumId) {
  let allItems = [];
  let pageToken = null;
  
  do {
    const response = await photosClient.mediaItems.search({
      albumId,
      pageSize: 100,
      pageToken
    });
    
    allItems = allItems.concat(response.mediaItems);
    pageToken = response.nextPageToken;
  } while (pageToken);
  
  return allItems;
}
```

---

## 三、Gemini API 相關

### Q5: Gemini 1.5 Flash 和 Pro 的差異是什麼?

**A**: 

| 特性 | Flash | Pro |
|------|-------|-----|
| **速度** | 極快 | 較慢 |
| **成本** | 低 | 高 |
| **分析深度** | 基礎 | 進階 |
| **適用場景** | 照片美學評分 | 影片動態分析 |
| **Context Window** | 1M tokens | 2M tokens |

**使用建議**:
- 照片分析: 使用 Flash (數量多,需快速處理)
- 影片分析: 使用 Pro (需深度理解動態與音訊)

### Q6: 如何設計有效的 Prompt 來評分照片?

**A**: 

**不良範例** (太模糊):
```
請評分這張照片。
```

**良好範例** (具體且結構化):
```
請以專業攝影師的角度分析這張照片,並給予 0-100 分的評分。

評分標準:
1. 構圖 (30%): 三分法、對稱性、視覺平衡
2. 曝光 (25%): 亮度適中、無過曝或欠曝
3. 清晰度 (25%): 對焦準確、無模糊
4. 色彩 (20%): 色調和諧、飽和度適當

請以 JSON 格式回傳:
{
  "score": 85,
  "composition": 28,
  "exposure": 22,
  "sharpness": 20,
  "color": 15,
  "recommendation": "keep" // 或 "discard"
}
```

### Q7: 如何處理 Gemini API 的 Token 限制?

**A**: 

**問題**: 一次傳送 500 張照片會超過 Token 限制

**解決方案**:
```javascript
// 分批處理
const BATCH_SIZE = 20; // 每批 20 張照片

async function analyzePhotosInBatches(photos) {
  const results = [];
  
  for (let i = 0; i < photos.length; i += BATCH_SIZE) {
    const batch = photos.slice(i, i + BATCH_SIZE);
    const batchResults = await analyzeWithGemini(batch);
    results.push(...batchResults);
    
    // 避免 Rate Limiting
    await sleep(1000); // 等待 1 秒
  }
  
  return results;
}
```

---

## 四、前端開發相關

### Q8: 如何實作即時進度顯示?

**A**: 使用 **Server-Sent Events (SSE)** 或 **WebSocket**

**SSE 範例** (較簡單,單向通訊):

**後端**:
```javascript
app.get('/api/analyze/stream', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // 模擬進度更新
  let progress = 0;
  const interval = setInterval(() => {
    progress += 10;
    res.write(`data: ${JSON.stringify({ progress })}\n\n`);
    
    if (progress >= 100) {
      clearInterval(interval);
      res.end();
    }
  }, 1000);
});
```

**前端**:
```javascript
const eventSource = new EventSource('/api/analyze/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  updateProgressBar(data.progress);
};
```

### Q9: 如何設計響應式的進度條?

**A**: 使用 CSS Grid 和動畫

```css
.progress-container {
  width: 100%;
  height: 8px;
  background: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  transition: width 0.3s ease;
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { background-position: -1000px 0; }
  100% { background-position: 1000px 0; }
}
```

---

## 五、錯誤處理相關

### Q10: 如何優雅地處理 API 錯誤?

**A**: 建立統一的錯誤處理中介軟體

```javascript
// utils/errorHandler.js
class APIError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}

// 錯誤處理中介軟體
app.use((err, req, res, next) => {
  console.error(err.stack);
  
  if (err instanceof APIError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message
    });
  }
  
  // 未知錯誤
  res.status(500).json({
    success: false,
    error: '伺服器發生錯誤,請稍後再試'
  });
});

// 使用範例
app.post('/api/analyze', async (req, res, next) => {
  try {
    if (!req.body.albumUrl) {
      throw new APIError('缺少相簿連結', 400);
    }
    // ... 處理邏輯
  } catch (error) {
    next(error);
  }
});
```

---

## 六、效能優化相關

### Q11: 如何加速大量照片的處理速度?

**A**: 使用 **並行處理** (Parallel Processing)

```javascript
// 不佳做法: 逐一處理 (慢)
for (const photo of photos) {
  await analyzePhoto(photo);
}

// 良好做法: 並行處理 (快)
const CONCURRENCY = 5; // 同時處理 5 張

async function analyzePhotosParallel(photos) {
  const chunks = [];
  for (let i = 0; i < photos.length; i += CONCURRENCY) {
    chunks.push(photos.slice(i, i + CONCURRENCY));
  }
  
  const results = [];
  for (const chunk of chunks) {
    const chunkResults = await Promise.all(
      chunk.map(photo => analyzePhoto(photo))
    );
    results.push(...chunkResults);
  }
  
  return results;
}
```

**效能提升**: 從 500 秒降至 100 秒 (5 倍速)

---

## 七、安全性相關

### Q12: 如何防止 API 金鑰外洩?

**A**: 

**✅ 正確做法**:
1. 使用 `.env` 檔案儲存金鑰
2. 將 `.env` 加入 `.gitignore`
3. 提供 `.env.example` 作為範本
4. 使用環境變數注入 (部署平台)

```javascript
// ✅ 正確
const apiKey = process.env.GEMINI_API_KEY;

// ❌ 錯誤
const apiKey = 'AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXX';
```

**❌ 常見錯誤**:
- 將 `.env` 上傳至 GitHub
- 在前端程式碼中使用 API 金鑰
- 將金鑰寫在註解中

---

## 八、部署相關

### Q13: 本地開發與生產環境有何差異?

**A**: 

| 項目 | 開發環境 | 生產環境 |
|------|---------|---------|
| **PORT** | 3000 | 80/443 |
| **協定** | HTTP | HTTPS |
| **錯誤訊息** | 詳細堆疊 | 簡化訊息 |
| **日誌** | Console | 檔案/服務 |
| **CORS** | 寬鬆 | 嚴格 |

**環境判斷**:
```javascript
const isDevelopment = process.env.NODE_ENV === 'development';

if (isDevelopment) {
  app.use(morgan('dev')); // 詳細日誌
} else {
  app.use(helmet()); // 安全標頭
  app.use(compression()); // 壓縮回應
}
```

---

## 九、學習資源

### 推薦閱讀

1. **Google Photos API**
   - [官方文件](https://developers.google.com/photos)
   - [快速入門指南](https://developers.google.com/photos/library/guides/get-started)

2. **Gemini API**
   - [Gemini API 文件](https://ai.google.dev/docs)
   - [Prompt 設計指南](https://ai.google.dev/docs/prompt_best_practices)

3. **Node.js 最佳實踐**
   - [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)
   - [Express.js 安全指南](https://expressjs.com/en/advanced/best-practice-security.html)

### 實用工具

- **Postman**: API 測試
- **ngrok**: 本地 HTTPS 測試
- **PM2**: Node.js 程序管理
- **Winston**: 日誌管理

---

## 十、待解決問題

### 🔴 高優先級

- [ ] 如何處理超過 10,000 個媒體項目的相簿?
- [ ] 如何實作斷點續傳功能?
- [ ] 如何優化 Gemini API 成本?

### 🟡 中優先級

- [ ] 是否需要加入使用者帳號系統?
- [ ] 如何實作分析歷史記錄?
- [ ] 是否支援離線模式?

### 🟢 低優先級

- [ ] 多語系支援
- [ ] 暗黑模式
- [ ] PWA 功能

---

**文件更新**: 隨著開發進度持續更新  
**貢獻者**: Antigravity AI Assistant

---

## 十一、Google Photos API 整合與問題排查實錄 (2025-12-30)

### Q14: 為什麼會出現 `google.photoslibrary is not a function` 錯誤?

**A**: 
這是因為 **`googleapis` Node.js 客戶端庫** 並沒有直接內建 Google Photos Library API 的便捷方法。雖然它是 Google 的官方庫，但 Photos Library 是獨立的 API。

**解決方案**:
棄用 `googleapis` 庫的內建調用方式，改用 **REST API** 直接呼叫。
我們引入了 `axios` 來發送 HTTP 請求：

```javascript
// ❌ 錯誤方式 (googleapis 庫不支援)
const photosLibrary = google.photoslibrary({ version: 'v1', auth: auth });
await photosLibrary.albums.list();

// ✅ 正確方式 (REST API)
const response = await axios.get('https://photoslibrary.googleapis.com/v1/albums', {
    headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
    }
});
```

### Q15: 為什麼 Scope 設定正確卻一直收到 `403 Forbidden` 錯誤?

**A**: 
這是一個非常具欺騙性的錯誤。當我們看到 403 時，通常會檢查：
1. **OAuth Scope**: 我們確認已包含 `photoslibrary.readonly` 和 `photoslibrary.appendonly`。
2. **測試使用者**: 我們確認開發者 Email 已在測試清單中。
3. **API 啟用**: 我們確認 Console 中已啟用 API。

但如果以上都正確，**根本原因通常是 Google Cloud 專案未啟用計費 (Billing)**。

Google Photos Library API 被視為「敏感」API，Google 強制要求專案必須連結計費帳戶才能使用，**即使是在免費配額內**。

### Q16: 如何解決這個 403 問題?

**A**: 
必須執行「行政」操作而非程式碼修改：

1. **啟用計費**:
   前往 Google Cloud Console > 計費 (Billing)，連結信用卡。
   *(注意：Photos Library API 每日有 10,000 次免費請求，一般使用不會產生費用)*

2. **重置授權**:
   啟用計費後，必須前往 [Google 帳戶權限頁面](https://myaccount.google.com/permissions) 移除應用程式的授權。

3. **重新登入**:
   回到應用程式重新觸發 OAuth 流程，讓 Google 重新驗證專案狀態。

這個經驗告訴我們：**當 Google API 出現權限問題且程式碼無誤時，第一時間檢查「計費帳戶」狀態。**

---

## 七、Path B (網頁爬蟲模式) 疑難排解

### Q17: 為什麼網頁爬蟲解析出 0 張照片？

**A**: 這是 Regex 模式不匹配的問題。

**問題診斷**:
```javascript
// 錯誤的 Regex (找不到任何照片)
const regex = /\["(https:\/\/lh3\.googleusercontent\.com\/[^"]+)",(\d+),(\d+)\]/g;
```

**Debug 步驟**:
1. 使用 `curl.exe` 下載實際 HTML:
   ```bash
   curl.exe -L "https://photos.app.goo.gl/xxxxx" -o debug_photos.html
   ```

2. 建立測試腳本檢查實際格式:
   ```javascript
   const fs = require('fs');
   const html = fs.readFileSync('debug_photos.html', 'utf8');
   // 測試不同 Regex 模式
   ```

3. 發現實際格式是 `"url",width,height` 而非 `["url",width,height]`

**正確的 Regex**:
```javascript
const regex = /"(https:\/\/lh3\.googleusercontent\.com\/[^"]+)",\s*(\d+),\s*(\d+)/g;
```

**關鍵差異**: 移除了 `\[` 和 `\]`，因為 Google Photos 的 JSON 結構中，URL 是作為陣列元素的第一項，而非獨立的陣列。

---

### Q18: Dashboard 頁面為什麼會閃退回首頁？

**A**: `auth.js` 的 DOMContentLoaded 事件強制檢查登入狀態。

**症狀**:
- 貼上連結後成功解析
- 跳轉到 `/dashboard.html?mode=scraped`
- 立即閃退回 `/`

**根本原因**:
```javascript
// public/js/auth.js
window.addEventListener('DOMContentLoaded', async () => {
    const isAuthenticated = await checkAuthStatus();
    if (protectedPages.includes(currentPage) && !isAuthenticated) {
        window.location.href = '/?error=auth_required'; // 這裡觸發閃退
    }
});
```

**解決方案**:
```javascript
window.addEventListener('DOMContentLoaded', async () => {
    // 檢查是否為 Scraped Mode - 如果是，則不需要驗證
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'scraped') {
        return; // 直接略過驗證
    }
    
    const isAuthenticated = await checkAuthStatus();
    // ... 其餘邏輯
});
```

---

### Q19: 分析進度為什麼卡在 0% 不動？

**A**: 這個問題有**兩個獨立的原因**需要同時修復。

**原因 1: SSE 端點返回 401**

**診斷過程**:
1. 打開瀏覽器 DevTools → Network 標籤
2. 發現 `/api/analysis/stream/:jobId` 返回 401 Unauthorized
3. 檢查 `routes/analysis.js` → 發現有 `requireAuth` 中間件

**問題代碼**:
```javascript
router.get('/stream/:jobId', requireAuth, (req, res) => {
    // SSE 邏輯
});
```

**解決方案**:
```javascript
router.get('/stream/:jobId', (req, res) => {  // 移除 requireAuth
    // SSE 邏輯
});
```

同樣需要修復 `/status/:jobId` 端點。

---

**原因 2: JobId 不同步**

**症狀**: 即使修復 SSE 認證，進度仍然卡住

**根本原因**:
```javascript
// routes/analysis.js
router.post('/start-scraped', async (req, res) => {
    // 啟動處理（內部生成 jobId_A）
    albumProcessorService.processScrapedPhotos(photos, {...});
    
    // 但回傳給前端的是另一個 jobId_B
    const jobId = `job_scraped_${Date.now()}_...`;
    res.json({ data: { jobId } });
});
```

前端用 `jobId_B` 查詢，但後端用 `jobId_A` 儲存進度 → 永遠查不到！

**解決方案**:
```javascript
// services/albumProcessor.js
async processScrapedPhotos(photos, options) {
    const jobId = this.generateJobId();
    
    // 初始化狀態
    this.jobs.set(jobId, { status: 'processing', ... });
    
    // 立即返回 jobId，讓處理在背景執行
    setImmediate(async () => {
        await this._processScrapedPhotosInternal(jobId, photos, ...);
    });
    
    return { jobId }; // 關鍵：立即返回
}

// routes/analysis.js
const result = await albumProcessorService.processScrapedPhotos(photos, {...});
res.json({ data: { jobId: result.jobId } }); // 使用返回的 jobId
```

---

### Q20: 分析完成後跳轉到結果頁又閃退？

**A**: Redirect 鏈未保留 `mode=scraped` 參數。

**問題流程**:
1. `dashboard.html?mode=scraped` → 開始分析
2. `analysis.html?jobId=xxx` ❌ 沒有 mode 參數
3. `results.html?jobId=xxx` ❌ 沒有 mode 參數
4. `auth.js` 檢查發現無 session → 閃退回首頁

**解決方案**: 在每個跳轉點都傳遞 mode 參數

```javascript
// dashboard.html
const analysisUrl = isScrapedMode 
    ? `/analysis.html?jobId=${result.jobId}&mode=scraped`
    : `/analysis.html?jobId=${result.jobId}`;
window.location.href = analysisUrl;

// analysis.html
const mode = urlParams.get('mode');
if (status.status === 'completed') {
    const resultsUrl = mode === 'scraped' 
        ? `/results.html?jobId=${jobId}&mode=scraped`
        : `/results.html?jobId=${jobId}`;
    window.location.href = resultsUrl;
}
```

---

### Q21: 為什麼相簿中的影片都被識別成照片？

**A**: 這是網頁爬蟲模式的**技術限制**，無法完美解決。

**原因**:
1. Google Photos 對照片和影片使用相同的縮圖 URL 格式
2. 從 HTML 中只能提取 `https://lh3.googleusercontent.com/...` URL
3. 無法從 URL 本身判斷是照片還是影片
4. 影片的預覽縮圖看起來就像靜態圖片

**目前做法**:
```javascript
// services/googlePhotos.js
photos.push({
    id: `scraped_${photos.length + 1}`,
    baseUrl: imageUrl,
    mimeType: 'image/jpeg', // 硬編碼為照片
    width, height,
    filename: `photo_${photos.length + 1}.jpg`
});
```

**影響**:
- 所有項目都被標記為 `image/jpeg`
- 影片使用照片的評分標準分析（構圖、曝光等）
- 影片數量顯示為 0

**解決方案**:
- **方案 A**: 啟用 Google Photos API（需要計費）→ 可獲得完整媒體類型資訊
- **方案 B**: 接受此限制 → 適用於純照片相簿或不需要區分的場景

---

### Q22: Gemini AI 評分標準是什麼？為什麼所有照片都不通過？

**A**: Gemini 使用多維度評分，標準相當嚴格。

**照片評分標準** (總分 100):
```javascript
const prompt = `
評分標準:
1. 構圖 (30%): 三分法、對稱性、視覺平衡
2. 曝光 (25%): 亮度適中、無過曝或欠曝
3. 清晰度 (25%): 對焦準確、無模糊
4. 色彩 (20%): 色調和諧、飽和度適當

如果總分 >= ${threshold}, recommendation 應為 "keep"
`;
```

**預設門檻**:
- 照片: 85 分
- 影片: 80 分

**為什麼 0/89 張保留**:
1. **門檻過高**: 85 分是專業攝影水準
2. **評分嚴格**: Gemini 對構圖、曝光要求很高
3. **照片品質**: 該批照片可能確實不符合標準

**建議調整**:
- 降低門檻至 50-60 分（一般照片水準）
- 或調整評分權重配置
- 或使用不同的相簿測試

**查看實際評分**:
可在後端日誌中看到每張照片的詳細評分:
```
照片分析完成: photo_1.jpg - 評分 58
  構圖: 18/30
  曝光: 15/25
  清晰度: 12/25
  色彩: 13/20
```

---

**更新日期**: 2025-12-31
